下面介绍迭代器的使用

-------------------------
    我们已经知道可以使用下标符来访问对象的字符或者成员对象。
接下来我们来介绍一种新的、更加通用的机制也可以达到相同的目的，这就是
迭代器。
    类似于指针类型，迭代器也提供了对对象的间接访问

1、使用迭代器
    和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有
返回迭代器的成员，比如begin和end成员，

--其中begin成员负责返回容器里指向第一个元素（或者第一个字符）的迭代器。--keynote
--end成员负责返回容器指向容器尾元素的(下一个位置)的迭代器。          --keynote
如果容器为空，则begin和end返回的是同一个迭代器，且都是尾后迭代器。--keynote
因此我们可以同时begin和end返回的迭代器来判断容器元素是否为空
如下：
     string s;
     if(s.begin() == s.end())
	printf("s字符串为空\n");
     else
	printf("s字符串不为空，里面至少有一个值\n");
编译结果：s字符串为空

2、迭代器运算符
标准容器迭代器的运算符
*iter  - 返回迭代器iter所指元素的引用-也就是iter指向的元素
（迭代器都点类似指针，但又和指针有所不同，可以借鉴指针学习，又发现里面的区别）
iter->mem - 解引用iter所指向元素的引用
++iter - 令iter指向容器中的下一个元素
--iter - 令iter指向容器中的上一个元素
iter1 == iter2 or iter1 ！= itera2 -- 有两种可能，（1）、容器里面有元素，但是两个迭代器指向相同的元素
（2）、容器里面没有元素，两个都指向容器里尾后迭代器

--string、vector等一些标准库类型右下标运算符，而并非全都如此。与之类似，（所有标准库容器的迭代器都定义了
==和!= ，但是他们中的大多数都没有定义<运算符。                        --keynote

接下来我们采用迭代器做了例子
	string s("test");
	if(s.begin() != s.end())//因为我使用Fira Code字体,可能不等号有些区别
	{	auto it = s.begin();//it类型尾迭代器类型，
		*it = toupper(*it);//toupper()函数是将里面的小写字母变为大写字母
	}	
编译结果: Test
我们就将字符串中第一个字符变为大写了，同理，通过迭代器的移动(++iter)，可以将字符串所有字符都变为大写等等
下面就是
	string s("test");
	for(auto it = s.begin();  it != s.end(); +it)
		*it = toupper(*it);
编译结果：TEST 
----目前分享这里，谢谢大家，祝福大家！

